<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>自定义引用类型的默认模式：构造函数+原型对象、动态原型模式、寄生构造函数模式、稳妥构造函数模式</title>
</head>
<body>
    <script>
        //1.构造函数+原型对象模式   ---     自定义类型（class）的默认模式
        //实例属性都是在构造函数定义的
        function Person(name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            this.friends = ['Shelby', 'Court'];
        }
        //实例只共享了原型属性constructor和方法sayName
        Person.prototype = {
            constructor: Person,
            sayName: function(){
                cosnole.log(this.name);
            }
        };
        var person1 = new Person("Nicholas", 29, "Software Engineer");
        var person2 = new Person("Greg", 27, "Doctor");
        person1.friends.push('Ana');
        console.log(person1.friends, person2.friends);     //['Shelby', 'Court', 'Ana'], ['Shelby', 'Court']
        console.log(person1.sayName === person2.sayName);  //true

        //2.判断是否需要初始化原型对象    ---    动态原型模式
        //所有的信息都封装在构造函数中，避免了单独的构造函数和原型
        function Perosn1 (name, age, job){
            this.name = name;
            this.age = age;
            this.job = job;
            //只有sayName方法不存在时，将sayName属性添加到原型中
            if(typeof this.sayName != 'function'){
                Perosn1.prototype.sayName = function(){
                    console.log(this.name);
                }
            }
        }
    </script>
</body>
</html>